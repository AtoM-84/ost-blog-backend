-- -----------------------------------------------------
-- Schemas OST blog
-- -----------------------------------------------------


BEGIN;
-- Note : BEGIN déclare le début d'une transaction : un groupe d'instructions SQL qui rend celles-ci dépendantes les unes des autres. 
-- Si au moins une des instructions génère une erreur, alors toutes les commandes sont invalidées.


-- Comme c'est un script de création de tables, on s'assure que celles-ci sont bien supprimées avant de les créer. 
-- On peut supprimer plusieurs tables en même temps
-- Note : attention à ne pas lancer ce script en production en revanche :wink:
DROP TABLE IF EXISTS "post",
"tag",
"author",
"comment",
"post_has_tag",
"post_has_author";

-- -----------------------------------------------------
-- Table "post"
-- -----------------------------------------------------
CREATE TABLE "post" (
  "id" INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, 
  "title" TEXT NOT NULL UNIQUE,
  "sub_title" TEXT NOT NULL UNIQUE,
  "content" TEXT NOT NULL UNIQUE,
  "created_at" TIMESTAMPTZ DEFAULT now() CURRENT_TIMESTAMP, -- Date où l'on insère un enregistrement dans la base
  "updated_at" TIMESTAMPTZ
);

/*
Notes :
  - id : 
    - La clé primaire est automatiquement NOT NULL. Pas besoin de le préciser.
    - On spécifie que la colonne sera générée automatiquement par la BDD en suivant une séquence numérique prédéfinie, s'incrémentant de 1 en 1.
    - On peut définir 'BY DEFAULT' (surcharge de la valeur possible) ou 'ALWAYS' (surcharge de la valeur impossible)
    - Ici on utilise BY DEFAULT, car on définit nous même les valeurs des clés primaires (dans le fichier de seeding).
    - Mais on utilisera plus généralement ALWAYS afin de sécurisé l'incrémentation des valeurs du champ
  - created_at 
    - CURRENT_TIMESTAMP : on peut aussi utiliser now()
*/


-- -----------------------------------------------------
-- Table "tag"
-- -----------------------------------------------------
CREATE TABLE "tag" (
  "id" INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  "name" TEXT NOT NULL,
  "color" TEXT NOT NULL,
);

-- -----------------------------------------------------
-- Table "author"
-- -----------------------------------------------------
CREATE TABLE "author" (
  "id" INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  "name" TEXT NOT NULL UNIQUE,
  "email" TEXT NOT NULL UNIQUE,
);

-- -----------------------------------------------------
-- Table "comment"
-- -----------------------------------------------------
CREATE TABLE "comment" (
  "id" INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  "created_at" TIMESTAMPTZ DEFAULT now() CURRENT_TIMESTAMP,
  "content" TEXT NOT NULL UNIQUE,
  "post_id" INTEGER NOT NULL REFERENCES "post"("id"),
  "author_id" INTEGER NOT NULL REFERENCES "author"("id"),
  UNIQUE ("post_id", "author_id")
);
-- UNIQUE créé une contrainte sur le couple sheet_id/tag_id qui doit alors être unique au sein de la BDD. 

-- -----------------------------------------------------
-- Table "post_has_tag"
-- -----------------------------------------------------
CREATE TABLE "post_has_tag" (
  "id" INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  "post_id" INTEGER NOT NULL REFERENCES "post"("id") DELETE ON CASCADE,
  "tag_id" INTEGER NOT NULL REFERENCES "tag"("id") DELETE ON CASCADE,
  UNIQUE ("post_id", "tag_id")
);

-- -----------------------------------------------------
-- Table "post_has_author"
-- -----------------------------------------------------
CREATE TABLE "post_has_author" (
  "id" INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  "post_id" INTEGER NOT NULL REFERENCES "post"("id") DELETE ON CASCADE,
  "author_id" INTEGER NOT NULL REFERENCES "author"("id") DELETE ON CASCADE,
  UNIQUE ("post_id", "author_id")
);


COMMIT; -- Pour mettre fin à au bloc de transaction et l'exécuter